#' Plot meteo data input as required by the 3DCMCCFEM model
#'
#' \code{plot_meteo_3DFEM} plot the variables in the input meteo file (e.g.,
#' generated by the function \code{make_meteo_EOBS}) required by the model.
#'
#' @param meteo_file_path Character: path to the simulation output file.
#' @param var Character vector: vector of variables name to be plotted. Default
#'   to "all" to plot all variables.
#' @param daterange Character vector of length 2: starting and ending date from
#'   which to plot meteo data. Must be in the form yyyy-mm-dd. Default to the
#'   time range of the EOBS dataset
#' @param window Numeric: the dimension of the focal window for computing the rolling
#'   mean. Expressed in days. Default to NULL (rolling mean is not plotted).
#' @param save_plot Logical: Should plots be saved in outdir? Default to FALSE.
#' @param outdir Character: path to the output directory.

#'
#' @details The function plots the time series of the specified variables as
#'   reported from  \code{make_meteo_EOBS}. It tries to guess the best time
#'   scale for the x-axis based on the \code{daterange} argument. The
#'   \code{window} argument should be appropriate to the desired time frame.
#'
#' @return A ggplot object if \code{save_plot=FALSE}, invisible otherwise. If
#'   \code{save_plot=TRUE} the function save in \code{outdir} a png file with
#'   the name of the site in \code{meteo_path_file}
#'
#' @seealso \code{\link[=run_3DFEM]{make_meteo_EOBS}}
#' @export
#'

plot_meteo_3DFEM <-
  function(meteo_file_path = NULL,
           var = "all",
           daterange = c("1980-01-01", "2022-06-30"),
           window = NULL,
           save_plot = FALSE,
           outdir = NULL) {


    if(!check_char(meteo_file_path))stop("meteo_file_path should be a valid path to a meteo.txt file")
    possible.args <-
      c("Rg_f",
        "Ta_f",
        "Tmax",
        "Tmin",
        "RH_f",
        "Precip",
        "all")
    var <- match.arg(var,possible.args,several.ok = TRUE)

    mt <- read.table(meteo_file_path, sep = "\t", header = T)
    time.col <- c("Year","Month","n_days")

    if(any(var!="all")){
      mt <- mt[,c(time.col,var)]
    }else {
      mt <- mt[,c(time.col,possible.args[-7])]
    }

    stopifnot("daterange must be a character vector of length 2"=check_len_char(daterange,2))
    daterange <- lubridate::ymd(daterange)
    mt$meteo_date <- lubridate::make_date(mt$Year,mt$Month,mt$n_days)

    start <- which(mt$meteo_date==daterange[1])
    end <- which(mt$meteo_date==daterange[2])
    if(!check_num(start)){
      warning("Starting date in daterange is not in the meteo file. Using first available date")
      start=1
    }
    if(!check_num(end)){
      warning("Ending date in daterange is not in the meteo file. Using last available date")
      end=nrow(mt)
    }
    mt <- mt[start:end,]

    if(any(var=="all")){
      m <- reshape2::melt(mt,id.vars="meteo_date",measure.vars=possible.args[-7])
    }else{
      m <- reshape2::melt(mt,id.vars="meteo_date",measure.vars=var)
    }

    text_size=40

    if(diff(range(mt$Year))>=5){
      brakes <- paste0(round(diff(range(mt$Year))/9)," year")
      label <- "%Y"
    }else{
      brakes <- paste0(round(diff(range(mt$Year))*12/10)," month")
      label <- "%y-%m"
    }

    meteo_plot <- ggplot2::ggplot(m)+
      ggplot2::facet_wrap(~variable,scale="free")+
      ggplot2::labs(x="date")+
      ggplot2::theme_bw(base_family = "serif")+
      ggplot2::theme(axis.title = ggplot2::element_text(size = text_size-2),
                     axis.text = ggplot2::element_text(size = text_size-9),
                     axis.text.x = ggplot2::element_text(angle=90),
                     panel.spacing = ggplot2::unit(2, "lines"),
                     legend.position = "none",
                     strip.background =ggplot2::element_rect(fill="white"),
                     strip.text = ggplot2::element_text(size = text_size),
                     strip.text.x = ggplot2::element_text(margin = ggplot2::margin(0,0,0.5,0, "cm")),
                     panel.background = ggplot2::element_rect(fill = 'transparent'),
                     panel.border = ggplot2::element_rect(linetype = 'solid', fill = 'transparent', color='black',linewidth=1.5))+
      ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size=5)))+
      ggplot2::scale_x_date(date_breaks = brakes, date_labels =  label)

    if(check_num(window)){
      meteo_plot <- meteo_plot+
        ggplot2::geom_line(ggplot2::aes(x=meteo_date,y=value,group=variable,col=variable),alpha=.3)+
        ggplot2::geom_line(data = m %>%
                             dplyr::group_by(variable) %>%
                             dplyr::mutate(rvalue = zoo::rollmean(.data[["value"]], window, align = "center", fill = "extend")),
                           ggplot2::aes(x=meteo_date,y=rvalue,group=variable,col=variable),linewidth=1.1)

    }else{
      meteo_plot <- meteo_plot+
        ggplot2::geom_line(ggplot2::aes(x=meteo_date,y=value,group=variable,col=variable))
    }

    if(save_plot){
      check_dir(outdir)
      name <- basename(meteo_file_path)
      site <- gsub("_meteo.txt","",name)
      ggplot2::ggsave(file.path(outdir,paste0(site,".png")),
             plot = meteo_plot, scale=1.8,width = 40,height = 30, units = "cm",
             dpi = 300)
      message(file.path(outdir,paste0(site,".png"))," saved!")
      return(invisible())

    }else{
      print(meteo_plot)
      return(meteo_plot)
    }
}
